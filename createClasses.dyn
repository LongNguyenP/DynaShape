{
  "Uuid": "98331f9f-4067-4e61-9831-82d8da9569b1",
  "IsCustomNode": false,
  "Description": "",
  "Name": "createClasses",
  "ElementResolver": {
    "ResolutionMap": {}
  },
  "Inputs": [],
  "Outputs": [],
  "Nodes": [
    {
      "ConcreteType": "CoreNodeModels.Input.StringInput, CoreNodeModels",
      "Id": "6fabbfab180d4e87ae472cf4fd979d19",
      "NodeType": "StringInputNode",
      "Inputs": [],
      "Outputs": [
        {
          "Id": "3dc00874a26f4dbca9ed3c91029ed701",
          "Name": "",
          "Description": "String",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "Creates a string",
      "InputValue": "  //==================================================================\r\n  // ConvexPolygonCollisionGoal\r\n  //==================================================================\r\n\r\n  /// <summary>\r\n  ///\r\n  /// </summary>\r\n  /// <param name=\"centers\"></param>\r\n  /// <param name=\"radii\"></param>\r\n  /// <param name=\"polygonVertices\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static ConvexPolygonCollisionGoal ConvexPolygonCollisionGoal_Create(\r\n      List<Point> centers,\r\n      List<float> radii,\r\n      [DefaultArgument(\"null\")] List<Point> polygonVertices,\r\n      [DefaultArgument(\"1000.0\")] float weight)\r\n  {\r\n      if (centers.Count != radii.Count)\r\n          throw new Exception(\"Error: centers count is not equal to radii count\");\r\n      return new ConvexPolygonCollisionGoal(\r\n          centers.ToTriples(),\r\n          radii,\r\n          polygonVertices == null ? new List<Triple>() : polygonVertices.ToTriples(),\r\n          weight);\r\n  }\r\n\r\n  /// <summary>\r\n  ///\r\n  /// </summary>\r\n  /// <param name=\"goal\"></param>\r\n  /// <param name=\"radii\"></param>\r\n  /// <param name=\"polygonVertices\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static ConvexPolygonCollisionGoal ConvexPolygonCollisionGoal_Change(\r\n      ConvexPolygonCollisionGoal goal,\r\n      [DefaultArgument(\"null\")] List<float> radii,\r\n      [DefaultArgument(\"null\")] List<Point> polygonVertices,\r\n      [DefaultArgument(\"-1.0\")] float weight)\r\n  {\r\n      if (radii != null)\r\n      {\r\n          if (goal.NodeCount != radii.Count)\r\n              throw new Exception(\"Error: radii count is not equal to node count\");\r\n          goal.Radii = radii.ToArray();\r\n      }\r\n\r\n      if (polygonVertices != null) goal.PolygonVertices = polygonVertices.ToTriples();\r\n      if (weight >= 0.0) goal.Weight = weight;\r\n      return goal;\r\n  }\r\n\r\n\r\n  //==================================================================\r\n  // ConvexPolygonContainmentGoal\r\n  //==================================================================\r\n\r\n  /// <summary>\r\n  ///\r\n  /// </summary>\r\n  /// <param name=\"centers\"></param>\r\n  /// <param name=\"radii\"></param>\r\n  /// <param name=\"polygonVertices\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static ConvexPolygonContainmentGoal ConvexPolygonContainmentGoal_Create(\r\n      List<Point> centers,\r\n      List<float> radii,\r\n      [DefaultArgument(\"null\")] List<Point> polygonVertices,\r\n      [DefaultArgument(\"1000.0\")] float weight)\r\n  {\r\n      if (centers.Count != radii.Count)\r\n          throw new Exception(\"Error: centers count is not equal to radii count\");\r\n      return new ConvexPolygonContainmentGoal(\r\n          centers.ToTriples(),\r\n          radii,\r\n          polygonVertices == null ? new List<Triple>() : polygonVertices.ToTriples(),\r\n          weight);\r\n  }\r\n\r\n  /// <summary>\r\n  ///\r\n  /// </summary>\r\n  /// <param name=\"goal\"></param>\r\n  /// <param name=\"radii\"></param>\r\n  /// <param name=\"polygonVertices\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static ConvexPolygonContainmentGoal ConvexPolygonContainmentGoal_Change(\r\n      ConvexPolygonContainmentGoal goal,\r\n      [DefaultArgument(\"null\")] List<float> radii,\r\n      [DefaultArgument(\"null\")] List<Point> polygonVertices,\r\n      [DefaultArgument(\"-1.0\")] float weight)\r\n  {\r\n      if (radii != null)\r\n      {\r\n          if (goal.NodeCount != radii.Count)\r\n              throw new Exception(\"Error: radii count is not equal to node count\");\r\n          goal.Radii = radii.ToArray();\r\n      }\r\n\r\n      if (polygonVertices != null) goal.PolygonVertices = polygonVertices.ToTriples();\r\n      if (weight >= 0.0) goal.Weight = weight;\r\n      return goal;\r\n  }\r\n\r\n\r\n\r\n  //==================================================================\r\n  // CoPlanar\r\n  //==================================================================\r\n\r\n  /// <summary>\r\n  /// Force a set of nodes to lie on a common plane.\r\n  /// The plane position and orientation are computed based on the current node positions.\r\n  /// This is different from the OnPlane goal, where the target plane is fixed and defined in advance.\r\n  /// </summary>\r\n  /// <param name=\"startPositions\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static CoPlanarGoal CoPlanarGoal_Create(\r\n      List<Point> startPositions,\r\n      [DefaultArgument(\"1.0\")] float weight)\r\n  {\r\n      return new CoPlanarGoal(startPositions.ToTriples(), weight);\r\n  }\r\n\r\n\r\n  /// <summary>\r\n  /// Adjust the goal's parameters while the solver is running.\r\n  /// </summary>\r\n  /// <param name=\"goal\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static CoPlanarGoal CoPlanarGoal_Change(\r\n      CoPlanarGoal goal,\r\n      [DefaultArgument(\"-1.0\")] float weight)\r\n  {\r\n      if (weight >= 0.0) goal.Weight = weight;\r\n      return goal;\r\n  }\r\n\r\n\r\n  //==================================================================\r\n  // CoSpherical\r\n  //==================================================================\r\n\r\n  /// <summary>\r\n  /// Force a set of nodes to lie on a common spherical surface.\r\n  /// The sphere position and radius are computed based the current node positions\r\n  /// </summary>\r\n  /// <param name=\"startPositions\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static CoSphericalGoal CoSphericalGoal_Create(\r\n      List<Point> startPositions,\r\n      [DefaultArgument(\"1.0\")] float weight)\r\n  {\r\n      return new CoSphericalGoal(startPositions.ToTriples(), weight);\r\n  }\r\n\r\n\r\n  /// <summary>\r\n  /// Adjust the goal's parameters while the solver is running.\r\n  /// </summary>\r\n  /// <param name=\"goal\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static CoSphericalGoal CoSphericalGoal_Change(\r\n      CoSphericalGoal goal,\r\n      [DefaultArgument(\"-1.0\")] float weight)\r\n  {\r\n      if (weight >= 0.0) goal.Weight = weight;\r\n      return goal;\r\n  }\r\n\r\n\r\n  //==================================================================\r\n  // Directional Wind\r\n  //==================================================================\r\n\r\n  /// <summary>\r\n  /// Simulate wind by applying a constant force on the three vertices of a triangle,\r\n  /// scaled by the cosine of the angle between the wind vector and the triangle's normal.\r\n  /// This way, the wind has full effect when it hits the triangle head-on, and zero\r\n  /// effect if it blows parallel to the triangle.\r\n  /// </summary>\r\n  /// <param name=\"startPosition1\"></param>\r\n  /// <param name=\"startPosition2\"></param>\r\n  /// <param name=\"startPosition3\"></param>\r\n  /// <param name=\"windVector\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static DirectionalWindGoal DirectionalWindGoal_Create(\r\n      Point startPosition1,\r\n      Point startPosition2,\r\n      Point startPosition3,\r\n      [DefaultArgument(\"Vector.ByCoordinates(1.0, 0, 0)\")] Vector windVector,\r\n      [DefaultArgument(\"1.0\")] float weight)\r\n  {\r\n      return new DirectionalWindGoal(\r\n          startPosition1.ToTriple(),\r\n          startPosition2.ToTriple(),\r\n          startPosition3.ToTriple(),\r\n          windVector.ToTriple(),\r\n          weight);\r\n  }\r\n\r\n\r\n  /// <summary>\r\n  /// Simulate wind blowing along a specified direction, by applying a force on the three vertices of a triangle,\r\n  /// The force magnitude is additionally scaled by the cosine of the angle between the wind vector and the triangle's normal.\r\n  /// This way, the wind has full effect when it hits the triangle head-on, and zero\r\n  /// effect if it blows parallel to the triangle.\r\n  /// </summary>\r\n  /// <param name=\"mesh\"></param>\r\n  /// <param name=\"windVector\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static List<DirectionalWindGoal> DirectionalWindGoal_Create(\r\n      Mesh mesh,\r\n      [DefaultArgument(\"Vector.ByCoordinates(1.0, 0, 0)\")] Vector windVector,\r\n      [DefaultArgument(\"1.0\")] float weight)\r\n  {\r\n      List<DirectionalWindGoal> windGoals = new List<DirectionalWindGoal>();\r\n\r\n      List<double> vertices = mesh.TrianglesAsNineNumbers.ToList();\r\n\r\n      int faceCount = vertices.Count / 9;\r\n\r\n      for (int i = 0; i < faceCount; i++)\r\n      {\r\n          int j = i * 9;\r\n          windGoals.Add(\r\n              new DirectionalWindGoal(\r\n                  new Triple(vertices[j + 0], vertices[j + 1], vertices[j + 2]),\r\n                  new Triple(vertices[j + 3], vertices[j + 4], vertices[j + 5]),\r\n                  new Triple(vertices[j + 6], vertices[j + 7], vertices[j + 8]),\r\n                  windVector.ToTriple(),\r\n                  weight));\r\n      }\r\n\r\n      return windGoals;\r\n  }\r\n\r\n\r\n  /// <summary>\r\n  /// Adjust the goal's parameters while the solver is running.\r\n  /// </summary>\r\n  /// <param name=\"goal\"></param>\r\n  /// <param name=\"windVector\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static DirectionalWindGoal DirectionalWindGoal_Change(\r\n      DirectionalWindGoal goal,\r\n      [DefaultArgument(\"null\")] Vector windVector,\r\n      [DefaultArgument(\"-1.0\")] float weight)\r\n  {\r\n      if (windVector != null) goal.WindVector = windVector.ToTriple();\r\n      if (weight >= 0.0) goal.Weight = weight;\r\n      return goal;\r\n  }\r\n\r\n\r\n  //==================================================================\r\n  // Direction\r\n  //==================================================================\r\n\r\n  /// <summary>\r\n  /// Force the line connecting two nodes to be parallel to the specified direction.\r\n  /// </summary>\r\n  /// <param name=\"startPosition1\"></param>\r\n  /// <param name=\"startPosition2\"></param>\r\n  /// <param name=\"targetDirection\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static DirectionGoal DirectionGoal_Create(\r\n      Point startPosition1,\r\n      Point startPosition2,\r\n      [DefaultArgument(\"null\")] Vector targetDirection,\r\n      [DefaultArgument(\"1.0\")] float weight)\r\n  {\r\n      return new DirectionGoal(\r\n          startPosition1.ToTriple(),\r\n          startPosition2.ToTriple(),\r\n          targetDirection?.ToTriple() ?? (startPosition2.ToTriple() - startPosition1.ToTriple()).Normalise(),\r\n          weight);\r\n  }\r\n\r\n\r\n  /// <summary>\r\n  /// Adjust the goal's parameters while the solver is running.\r\n  /// </summary>\r\n  /// <param name=\"goal\"></param>\r\n  /// <param name=\"targetDirection\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static DirectionGoal DirectionGoal_Change(\r\n      DirectionGoal goal,\r\n      [DefaultArgument(\"null\")] Vector targetDirection,\r\n      [DefaultArgument(\"-1.0\")] float weight)\r\n  {\r\n      if (targetDirection != null) goal.TargetDirection = targetDirection.ToTriple();\r\n      if (weight >= 0.0) goal.Weight = weight;\r\n      return goal;\r\n  }\r\n\r\n\r\n  //==================================================================\r\n  // EqualLength\r\n  //==================================================================\r\n\r\n  /// <summary>\r\n  /// Force a sequence of nodes to maintain equal distances.\r\n  /// </summary>\r\n  /// <param name=\"startPositions\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static EqualLengthsGoal EqualLengthsGoal_Create(\r\n      List<Point> startPositions,\r\n      [DefaultArgument(\"1.0\")] float weight)\r\n  {\r\n      List<Triple> triples = new List<Triple> { startPositions[0].ToTriple() };\r\n\r\n      for (int i = 1; i < startPositions.Count - 1; i++)\r\n      {\r\n          triples.Add(startPositions[i].ToTriple());\r\n          triples.Add(triples[triples.Count - 1]);\r\n      }\r\n\r\n      triples.Add(startPositions[startPositions.Count - 1].ToTriple());\r\n\r\n      return new EqualLengthsGoal(triples, weight);\r\n  }\r\n\r\n\r\n  /// <summary>\r\n  /// Force a set of line segments to maintain equal lengths.\r\n  /// </summary>\r\n  /// <param name=\"lineStarts\"></param>\r\n  /// <param name=\"lineEnds\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static EqualLengthsGoal EqualLengthsGoal_Create(\r\n      List<Point> lineStarts,\r\n      List<Point> lineEnds,\r\n      [DefaultArgument(\"1.0\")] float weight)\r\n  {\r\n      List<Triple> triples = new List<Triple>();\r\n\r\n      int n = lineStarts.Count < lineEnds.Count ? lineStarts.Count : lineEnds.Count;\r\n\r\n      for (int i = 0; i < n; i++)\r\n      {\r\n          triples.Add(lineStarts[i].ToTriple());\r\n          triples.Add(lineEnds[i].ToTriple());\r\n      }\r\n\r\n      return new EqualLengthsGoal(triples, weight);\r\n  }\r\n\r\n\r\n  /// <summary>\r\n  /// Force a set of line segments to maintain equal lengths.\r\n  /// </summary>\r\n  /// <param name=\"lines\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static EqualLengthsGoal EqualLengthsGoal_Create(\r\n      List<Line> lines,\r\n      [DefaultArgument(\"1.0\")] float weight)\r\n  {\r\n      List<Triple> startPositions = new List<Triple>();\r\n      foreach (Line line in lines)\r\n      {\r\n          startPositions.Add(line.StartPoint.ToTriple());\r\n          startPositions.Add(line.EndPoint.ToTriple());\r\n      }\r\n      return new EqualLengthsGoal(startPositions, weight);\r\n  }\r\n\r\n\r\n  /// <summary>\r\n  /// Adjust the goal's parameters while the solver is running.\r\n  /// </summary>\r\n  /// <param name=\"goal\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static EqualLengthsGoal EqualLengthsGoal_Change(\r\n      EqualLengthsGoal goal,\r\n      [DefaultArgument(\"-1.0\")] float weight)\r\n  {\r\n      if (weight >= 1.0) goal.Weight = weight;\r\n      return goal;\r\n  }\r\n\r\n\r\n  //==================================================================\r\n  // Floor\r\n  //==================================================================\r\n\r\n  /// <summary>\r\n  /// Force a set of nodes to stay above a horizontal floor plane.\r\n  /// </summary>\r\n  /// <param name=\"startPositions\"></param>\r\n  /// <param name=\"floorHeight\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static FloorGoal FloorGoal_Create(\r\n      List<Point> startPositions,\r\n      [DefaultArgument(\"0.0\")] float floorHeight,\r\n      [DefaultArgument(\"1000.0\")] float weight)\r\n  {\r\n      return new FloorGoal(startPositions.ToTriples(), floorHeight, weight);\r\n  }\r\n\r\n\r\n  /// <summary>\r\n  /// Adjust the goal's parameters while the solver is running.\r\n  /// </summary>\r\n  /// <param name=\"goal\"></param>\r\n  /// <param name=\"floorHeight\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static FloorGoal FloorGoal_Change(\r\n      FloorGoal goal,\r\n      [DefaultArgument(\"0.0\")] float floorHeight,\r\n      [DefaultArgument(\"-1.0\")] float weight)\r\n  {\r\n      goal.FloorHeight = floorHeight;\r\n      if (weight > 0.0) goal.Weight = weight;\r\n      return goal;\r\n  }\r\n\r\n\r\n  //==================================================================\r\n  // Length\r\n  //==================================================================\r\n\r\n  /// <summary>\r\n  /// Force a pair of nodes to maintain the specified distance/length\r\n  /// </summary>\r\n  /// <param name=\"startPosition1\"></param>\r\n  /// <param name=\"startPosition2\"></param>\r\n  /// <param name=\"targetLength\">If unspecified, the target length will be the distance between the starting node positions</param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static LengthGoal LengthGoal_Create(\r\n      Point startPosition1,\r\n      Point startPosition2,\r\n      [DefaultArgument(\"-1.0\")] float targetLength,\r\n      [DefaultArgument(\"1.0\")] float weight)\r\n  {\r\n      return new LengthGoal(\r\n          startPosition1.ToTriple(),\r\n          startPosition2.ToTriple(),\r\n          targetLength >= 0.0\r\n              ? targetLength\r\n              : (startPosition2.ToTriple() - startPosition1.ToTriple()).Length,\r\n          weight);\r\n  }\r\n\r\n\r\n  /// <summary>\r\n  /// Maintain the specified distance between two nodes located at the start and end of the given line\r\n  /// </summary>\r\n  /// <param name=\"line\">This line will be used to create two nodes located at is start and end point</param>\r\n  /// <param name=\"targetLength\">If unspecified, the target length will be the distance between the starting node positions</param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static LengthGoal LengthGoal_Create(\r\n      Line line,\r\n      [DefaultArgument(\"-1.0\")] float targetLength,\r\n      [DefaultArgument(\"1.0\")] float weight)\r\n  {\r\n      return new LengthGoal(\r\n          line.StartPoint.ToTriple(),\r\n          line.EndPoint.ToTriple(),\r\n          targetLength >= 0.0 ? targetLength : (float)line.Length,\r\n          weight);\r\n  }\r\n\r\n\r\n  /// <summary>\r\n  /// Adjust the goal's parameters while the solver is running.\r\n  /// </summary>\r\n  /// <param name=\"goal\"></param>\r\n  /// <param name=\"targetLength\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static LengthGoal LengthGoal_Change(\r\n      LengthGoal goal,\r\n      [DefaultArgument(\"-1.0\")] float targetLength,\r\n      [DefaultArgument(\"-1.0\")] float weight)\r\n  {\r\n      if (targetLength >= 0.0) goal.TargetLength = targetLength;\r\n      if (weight >= 0.0) goal.Weight = weight;\r\n      return goal;\r\n  }\r\n\r\n\r\n  //==================================================================\r\n  // Merge\r\n  //==================================================================\r\n\r\n  /// <summary>\r\n  /// Pull a set of nodes to their center of mass.\r\n  /// This is useful to force the nodes to have coincident positions.\r\n  /// By default the weight value is set very high to ensure that the nodes really merge together at one position.\r\n  /// </summary>\r\n  /// <param name=\"startPositions\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static MergeGoal MergeGoal_Create(\r\n      List<Point> startPositions,\r\n      [DefaultArgument(\"1000.0\")] float weight)\r\n  {\r\n      return new MergeGoal(startPositions.ToTriples(), weight);\r\n  }\r\n\r\n\r\n  /// <summary>\r\n  /// Adjust the goal's parameters while the solver is running.\r\n  /// </summary>\r\n  /// <param name=\"goal\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static MergeGoal MergeGoal_Change(\r\n      MergeGoal goal,\r\n      [DefaultArgument(\"-1.0\")] float weight)\r\n  {\r\n      if (weight >= 0.0) goal.Weight = weight;\r\n      return goal;\r\n  }\r\n\r\n\r\n  //==================================================================\r\n  // OnCurve\r\n  //==================================================================\r\n\r\n  /// <summary>\r\n  /// Force a set of nodes to lie on the specified curve.\r\n  /// </summary>\r\n  /// <param name=\"startPositions\"></param>\r\n  /// <param name=\"targetCurve\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static OnCurveGoal OnCurveGoal_Create(\r\n      List<Point> startPositions,\r\n      Curve targetCurve,\r\n      [DefaultArgument(\"1.0\")] float weight)\r\n  {\r\n      return new OnCurveGoal(startPositions.ToTriples(), targetCurve, weight);\r\n  }\r\n\r\n\r\n  /// <summary>\r\n  /// Adjust the goal's parameters while the solver is running.\r\n  /// </summary>\r\n  /// <param name=\"goal\"></param>\r\n  /// <param name=\"targetCurve\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static OnCurveGoal OnCurveGoal_Change(\r\n      OnCurveGoal goal,\r\n      [DefaultArgument(\"null\")] Curve targetCurve,\r\n      float weight)\r\n  {\r\n      if (targetCurve != null) goal.TargetCurve = targetCurve;\r\n      if (weight >= 0.0) goal.Weight = weight;\r\n      return goal;\r\n  }\r\n\r\n\r\n  //==================================================================\r\n  // OnLine\r\n  //==================================================================\r\n\r\n  /// <summary>\r\n  /// Force a set of nodes to lie on the specified line.\r\n  /// This is different from other CoLinear goal, where the target line is computed based on the current node positions rather than being defined and fixed in advance.\r\n  /// </summary>\r\n  /// <param name=\"startPosition\"></param>\r\n  /// <param name=\"targetLineOrigin\"></param>\r\n  /// <param name=\"targetLineDirection\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static OnLineGoal OnLineGoal_Create(\r\n      List<Point> startPosition,\r\n      [DefaultArgument(\"Point.Origin()\")] Point targetLineOrigin,\r\n      [DefaultArgument(\"Vector.XAxis()\")] Vector targetLineDirection,\r\n      [DefaultArgument(\"1.0\")] float weight)\r\n  {\r\n      return new OnLineGoal(\r\n          startPosition.ToTriples(),\r\n          targetLineOrigin.ToTriple(),\r\n          targetLineDirection.ToTriple().Normalise(),\r\n          weight);\r\n  }\r\n\r\n\r\n  /// <summary>\r\n  /// Force a set of nodes to lie on the specified line.\r\n  /// This is different from other CoLinear goal, where the target line is computed based on the current node positions rather than being defined and fixed in advance.\r\n  /// </summary>\r\n  /// <param name=\"startPositions\"></param>\r\n  /// <param name=\"targetLine\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static OnLineGoal OnLineGoal_Create(\r\n      List<Point> startPositions,\r\n      [DefaultArgument(\"Line.ByStartPointEndPoint(Point.Origin(), Point.ByCoordinates(1.0, 0.0, 0.0))\")] Line\r\n          targetLine,\r\n      [DefaultArgument(\"1.0\")] float weight)\r\n  {\r\n      return new OnLineGoal(startPositions.ToTriples(), targetLine, weight);\r\n  }\r\n\r\n\r\n  /// <summary>\r\n  /// Adjust the goal's parameters while the solver is running.\r\n  /// </summary>\r\n  /// <param name=\"goal\"></param>\r\n  /// <param name=\"targetLineOrigin\"></param>\r\n  /// <param name=\"targetLineDirection\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static OnLineGoal OnLineGoal_Change(\r\n      OnLineGoal goal,\r\n      [DefaultArgument(\"null\")] Point targetLineOrigin,\r\n      [DefaultArgument(\"null\")] Vector targetLineDirection,\r\n      [DefaultArgument(\"-1.0\")] float weight)\r\n  {\r\n      if (targetLineOrigin != null) goal.TargetLineOrigin = targetLineOrigin.ToTriple();\r\n      if (targetLineDirection != null) goal.TargetLineDirection = targetLineDirection.ToTriple();\r\n      if (weight >= 0.0) goal.Weight = weight;\r\n      return goal;\r\n  }\r\n\r\n\r\n  /// <summary>\r\n  /// Adjust the goal's parameters while the solver is running.\r\n  /// </summary>\r\n  /// <param name=\"goal\"></param>\r\n  /// <param name=\"targetLine\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static OnLineGoal OnLineGoal_Change(\r\n      OnLineGoal goal,\r\n      [DefaultArgument(\"null\")] Line targetLine,\r\n      [DefaultArgument(\"-1.0\")] float weight)\r\n  {\r\n      if (targetLine != null)\r\n      {\r\n          goal.TargetLineOrigin = targetLine.StartPoint.ToTriple();\r\n          goal.TargetLineDirection =\r\n              (targetLine.EndPoint.ToTriple() - targetLine.StartPoint.ToTriple()).Normalise();\r\n      }\r\n\r\n      if (weight >= 0.0) goal.Weight = weight;\r\n      return goal;\r\n  }\r\n\r\n\r\n  //==================================================================\r\n  // OnPlane\r\n  //==================================================================\r\n\r\n  /// <summary>\r\n  /// Force a set of nodes to lie on the specified plane.\r\n  /// This is different from other CoPlanar goal, where the target plane is computed based on the current node positions rather than being defined and fixed in advance.\r\n  /// </summary>\r\n  /// <param name=\"startPositions\"></param>\r\n  /// <param name=\"targetPlaneOrigin\"></param>\r\n  /// <param name=\"targetPlaneNormal\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static OnPlaneGoal OnPlaneGoal_Create(\r\n      List<Point> startPositions,\r\n      [DefaultArgument(\"Point.Origin()\")] Point targetPlaneOrigin,\r\n      [DefaultArgument(\"Vector.ZAxis()\")] Vector targetPlaneNormal,\r\n      [DefaultArgument(\"1.0\")] float weight)\r\n  {\r\n      return new OnPlaneGoal(\r\n          startPositions.ToTriples(),\r\n          targetPlaneOrigin.ToTriple(),\r\n          targetPlaneNormal.ToTriple(),\r\n          weight);\r\n  }\r\n\r\n  /// <summary>\r\n  /// Force a set of nodes to lie on the specified plane.\r\n  /// This is different from other CoPlanar goal, where the target plane is computed based on the current node positions rather than being defined and fixed in advance.\r\n  /// </summary>\r\n  /// <param name=\"startPositions\"></param>\r\n  /// <param name=\"targetPlane\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static OnPlaneGoal OnPlaneGoal_Create(\r\n      List<Point> startPositions,\r\n      [DefaultArgument(\"Plane.ByOriginNormal(Point.Origin(), Vector.ZAxis())\")] Plane targetPlane,\r\n      [DefaultArgument(\"1.0\")] float weight)\r\n  {\r\n      return new OnPlaneGoal(startPositions.ToTriples(), targetPlane.Origin.ToTriple(),\r\n          targetPlane.Normal.ToTriple(), weight);\r\n  }\r\n\r\n\r\n  /// <summary>\r\n  /// Adjust the goal's parameters while the solver is running.\r\n  /// </summary>\r\n  /// <param name=\"goal\"></param>\r\n  /// <param name=\"targetPlaneOrigin\"></param>\r\n  /// <param name=\"targetPlaneNormal\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static OnPlaneGoal OnPlaneGoal_Change(\r\n      OnPlaneGoal goal,\r\n      [DefaultArgument(\"null\")] Point targetPlaneOrigin,\r\n      [DefaultArgument(\"null\")] Vector targetPlaneNormal,\r\n      [DefaultArgument(\"-1.0\")] float weight)\r\n  {\r\n      if (targetPlaneOrigin != null) goal.TargetPlaneOrigin = targetPlaneOrigin.ToTriple();\r\n      if (targetPlaneNormal != null) goal.TargetPlaneNormal = targetPlaneNormal.ToTriple();\r\n      if (weight >= 0.0) goal.Weight = weight;\r\n      return goal;\r\n  }\r\n\r\n\r\n  /// <summary>\r\n  /// Adjust the goal's parameters while the solver is running.\r\n  /// </summary>\r\n  /// <param name=\"goal\"></param>\r\n  /// <param name=\"targetPlane\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static OnPlaneGoal OnPlaneGoal_Change(\r\n      OnPlaneGoal goal,\r\n      [DefaultArgument(\"null\")] Plane targetPlane,\r\n      [DefaultArgument(\"-1.0\")] float weight)\r\n  {\r\n      if (targetPlane != null)\r\n      {\r\n          goal.TargetPlaneOrigin = targetPlane.Origin.ToTriple();\r\n          goal.TargetPlaneNormal = targetPlane.Normal.ToTriple();\r\n      }\r\n      if (weight >= 0.0) goal.Weight = weight;\r\n      return goal;\r\n  }\r\n\r\n\r\n  //==================================================================\r\n  // OnSurface\r\n  //==================================================================\r\n\r\n  /// <summary>\r\n  /// Force a set of nodes to lie on the specified surface.\r\n  /// </summary>\r\n  /// <param name=\"startPositions\"></param>\r\n  /// <param name=\"targetSurface\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static OnSurfaceGoal OnSurfaceGoal_Create(\r\n      List<Point> startPositions,\r\n      Surface targetSurface,\r\n      [DefaultArgument(\"1.0\")] float weight)\r\n  {\r\n      return new OnSurfaceGoal(startPositions.ToTriples(), targetSurface, weight);\r\n  }\r\n\r\n\r\n  /// <summary>\r\n  /// Adjust the goal's parameters while the solver is running.\r\n  /// </summary>\r\n  /// <param name=\"goal\"></param>\r\n  /// <param name=\"targetSurface\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static OnSurfaceGoal OnSurfaceGoal_Change(\r\n      OnSurfaceGoal goal,\r\n      [DefaultArgument(\"null\")] Surface targetSurface,\r\n      float weight)\r\n  {\r\n      if (targetSurface != null) goal.TargetSurface = targetSurface;\r\n      if (weight >= 0.0) goal.Weight = weight;\r\n      return goal;\r\n  }\r\n\r\n\r\n  //==================================================================\r\n  // ParallelLines\r\n  //==================================================================\r\n\r\n  /// <summary>\r\n  /// Force a set of lines to be parallel.\r\n  /// </summary>\r\n  /// <param name=\"lineStartPoints\"></param>\r\n  /// <param name=\"lineEndPoints\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static ParallelLinesGoal ParallelLinesGoal_Create(\r\n      List<Point> lineStartPoints,\r\n      List<Point> lineEndPoints,\r\n      [DefaultArgument(\"1.0\")] float weight)\r\n  {\r\n      if (lineStartPoints.Count != lineEndPoints.Count)\r\n          throw new Exception(\"Error: lineStartPoints count is not equal to lineEndPoints count\");\r\n\r\n      List<Triple> pointPairs = new List<Triple>();\r\n\r\n      for (int i = 0; i < lineStartPoints.Count; i++)\r\n      {\r\n          pointPairs.Add(lineStartPoints[i].ToTriple());\r\n          pointPairs.Add(lineEndPoints[i].ToTriple());\r\n      }\r\n\r\n      return new ParallelLinesGoal(pointPairs, weight);\r\n  }\r\n\r\n\r\n  /// <summary>\r\n  /// Force a set of lines to be parallel.\r\n  /// </summary>\r\n  /// <param name=\"lines\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static ParallelLinesGoal ParallelLinesGoal_Create(\r\n      List<Line> lines,\r\n      [DefaultArgument(\"1.0\")] float weight)\r\n  {\r\n      List<Triple> startPositions = new List<Triple>();\r\n      foreach (Line line in lines)\r\n      {\r\n          startPositions.Add(line.StartPoint.ToTriple());\r\n          startPositions.Add(line.EndPoint.ToTriple());\r\n      }\r\n      return new ParallelLinesGoal(startPositions, weight);\r\n  }\r\n\r\n\r\n  /// <summary>\r\n  /// Adjust the goal's parameters while the solver is running.\r\n  /// </summary>\r\n  /// <param name=\"goal\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static ParallelLinesGoal ParallelLinesGoal_Change(\r\n      ParallelLinesGoal goal,\r\n      [DefaultArgument(\"-1.0\")] float weight)\r\n  {\r\n      if (weight >= 0.0) goal.Weight = weight;\r\n      return goal;\r\n  }\r\n\r\n\r\n\r\n  //==================================================================\r\n  // ShapeMatching\r\n  //==================================================================\r\n\r\n  /// <summary>\r\n  /// Move a set of nodes to positions that resemble a target shape.\r\n  /// The target shape is defined by a sequence of points, in the same order as how the nodes are specified.\r\n  /// </summary>\r\n  /// <param name=\"startPositions\"></param>\r\n  /// <param name=\"targetShapePoints\"></param>\r\n  /// <param name=\"allowScaling\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static ShapeMatchingGoal ShapeMatchingGoal_Create(\r\n      List<Point> startPositions,\r\n      [DefaultArgument(\"null\")] List<Point> targetShapePoints,\r\n      [DefaultArgument(\"false\")] bool allowScaling,\r\n      [DefaultArgument(\"1.0\")] float weight)\r\n  {\r\n      return targetShapePoints == null\r\n          ? new ShapeMatchingGoal(startPositions.ToTriples(), allowScaling, weight)\r\n          : new ShapeMatchingGoal(startPositions.ToTriples(), targetShapePoints.ToTriples(), allowScaling,\r\n              weight);\r\n  }\r\n\r\n\r\n  /// <summary>\r\n  /// Adjust the goal's parameters while the solver is running.\r\n  /// </summary>\r\n  /// <param name=\"goal\"></param>\r\n  /// <param name=\"targetShapePoints\"></param>\r\n  /// <param name=\"allowScaling\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static ShapeMatchingGoal ShapeMatchingGoal_Change(\r\n      ShapeMatchingGoal goal,\r\n      [DefaultArgument(\"null\")] List<Point> targetShapePoints,\r\n      [DefaultArgument(\"false\")] bool? allowScaling,\r\n      [DefaultArgument(\"-1.0\")] float weight)\r\n  {\r\n      if (targetShapePoints != null) goal.SetTargetShapePoints(targetShapePoints.ToTriples());\r\n      if (weight >= 0.0) goal.Weight = weight;\r\n      if (allowScaling.HasValue) goal.AllowScaling = allowScaling.Value;\r\n      return goal;\r\n  }\r\n\r\n\r\n  //==================================================================\r\n  // SphereCollision\r\n  //==================================================================\r\n\r\n  /// <summary>\r\n  /// Maintain minimum distance between the nodes\r\n  /// </summary>\r\n  /// <param name=\"centers\"></param>\r\n  /// <param name=\"radii\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static SphereCollisionGoal SphereCollisionGoal_Create(\r\n      List<Point> centers,\r\n      List<float> radii,\r\n      [DefaultArgument(\"1.0\")] float weight)\r\n  {\r\n      if (centers.Count != radii.Count)\r\n          throw new Exception(\"Error: centers count is not equal to radii count\");\r\n\r\n      return new SphereCollisionGoal(centers.ToTriples(), radii, weight);\r\n  }\r\n\r\n\r\n  /// <summary>\r\n  /// Maintain minimum distance between the nodes and the (static) lines\r\n  /// </summary>\r\n  /// <param name=\"goal\"></param>\r\n  /// <param name=\"radii\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static SphereCollisionGoal SphereCollisionGoal_Change(\r\n      SphereCollisionGoal goal,\r\n      [DefaultArgument(\"null\")] List<float> radii,\r\n      [DefaultArgument(\"-1.0\")] float weight)\r\n  {\r\n      if (radii != null)\r\n      {\r\n          if (goal.NodeCount != radii.Count)\r\n              throw new Exception(\"Error: radii count is not equal to node count\");\r\n          goal.Radii = radii.ToArray();\r\n      }\r\n\r\n      if (weight >= 0.0) goal.Weight = weight;\r\n      return goal;\r\n  }\r\n\r\n  //==================================================================\r\n  // SphereStaticLineCollision\r\n  //==================================================================\r\n\r\n  /// <summary>\r\n  /// Move a set of nodes to positions that resemble a target shape.\r\n  /// The target shape is defined by a sequence of points, in the same order as how the nodes are specified.\r\n  /// </summary>\r\n  /// <param name=\"centers\"></param>\r\n  /// <param name=\"radii\"></param>\r\n  /// <param name=\"lines\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static SphereStaticLineCollisionGoal SphereStaticLineCollisionGoal_Create(\r\n      List<Point> centers,\r\n      List<float> radii,\r\n      [DefaultArgument(\"null\")] List<Line> lines,\r\n      [DefaultArgument(\"1.0\")] float weight)\r\n  {\r\n      if (centers.Count != radii.Count)\r\n          throw new Exception(\"Error: centers count is not equal to radii count\");\r\n\r\n      List<Triple> lineStarts = new List<Triple>();\r\n      List<Triple> lineEnds = new List<Triple>();\r\n\r\n      if (lines != null)\r\n          foreach (Line line in lines)\r\n          {\r\n              lineStarts.Add(line.StartPoint.ToTriple());\r\n              lineEnds.Add(line.EndPoint.ToTriple());\r\n          }\r\n\r\n      return new SphereStaticLineCollisionGoal(centers.ToTriples(), radii, lineStarts, lineEnds, weight);\r\n  }\r\n\r\n\r\n  /// <summary>\r\n  /// Adjust the goal's parameters while the solver is running.\r\n  /// </summary>\r\n  /// <param name=\"goal\"></param>\r\n  /// <param name=\"radii\"></param>\r\n  /// <param name=\"lines\"></param>\r\n  /// <param name=\"weight\"></param>\r\n  /// <returns></returns>\r\n  public static SphereStaticLineCollisionGoal SphereStaticLineCollisionGoal_Change(\r\n      SphereStaticLineCollisionGoal goal,\r\n      [DefaultArgument(\"null\")] List<float> radii,\r\n      [DefaultArgument(\"null\")] List<Line> lines,\r\n      [DefaultArgument(\"-1.0\")] float weight)\r\n  {\r\n      if (radii != null)\r\n      {\r\n          if (goal.NodeCount != radii.Count)\r\n              throw new Exception(\"Error: radii count is not equal to node count\");\r\n          goal.Radii = radii.ToArray();\r\n      }\r\n\r\n      if (lines != null)\r\n      {\r\n          goal.LineStarts = new List<Triple>(lines.Count);\r\n          goal.LineEnds = new List<Triple>(lines.Count);\r\n\r\n          for (int i = 0; i < lines.Count; i++)\r\n          {\r\n              goal.LineStarts.Add(lines[i].StartPoint.ToTriple());\r\n              goal.LineStarts.Add(lines[i].EndPoint.ToTriple());\r\n          }\r\n      }\r\n\r\n      if (weight >= 0.0) goal.Weight = weight;\r\n      return goal;\r\n  }"
    },
    {
      "ConcreteType": "Dynamo.Graph.Nodes.ZeroTouch.DSVarArgFunction, DynamoCore",
      "FunctionSignature": "DSCore.String.Split@string,string[]",
      "FunctionType": "VariableArgument",
      "Id": "f9d88a0265954657b0318b4f0dcc2d6a",
      "NodeType": "FunctionNode",
      "Inputs": [
        {
          "Id": "9013cfd54b11442fb56f3b46d076fa15",
          "Name": "string",
          "Description": "String to split up\n\nstring",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        },
        {
          "Id": "7b9f298689924d12816bffbc0d55f09b",
          "Name": "separator0",
          "Description": "Strings that, if present, determine the end and start of a split.\n\nstring[]",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Outputs": [
        {
          "Id": "d3992f15452945f4bea0ce0ed8667a6f",
          "Name": "strings",
          "Description": "List of strings made from the input string",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Auto",
      "Description": "Divides a single string into a list of strings, with divisions determined by the given separator strings.\n\nString.Split (string: string, separators: string[]): string[]"
    },
    {
      "ConcreteType": "CoreNodeModels.Input.StringInput, CoreNodeModels",
      "Id": "66d7f364dc6349bc9d8ebaf5cb104d8c",
      "NodeType": "StringInputNode",
      "Inputs": [],
      "Outputs": [
        {
          "Id": "774087cb9e0c4a38a60a37d38c288575",
          "Name": "",
          "Description": "String",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "Creates a string",
      "InputValue": "public static "
    },
    {
      "ConcreteType": "CoreNodeModels.Input.StringInput, CoreNodeModels",
      "Id": "2b846337d8bd409dbd6f177104a57270",
      "NodeType": "StringInputNode",
      "Inputs": [],
      "Outputs": [
        {
          "Id": "641e26b436e24fe4be000914b3245a2f",
          "Name": "",
          "Description": "String",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "Creates a string",
      "InputValue": " "
    },
    {
      "ConcreteType": "Dynamo.Graph.Nodes.ZeroTouch.DSVarArgFunction, DynamoCore",
      "FunctionSignature": "DSCore.String.Split@string,string[]",
      "FunctionType": "VariableArgument",
      "Id": "f802dc9b651541798ecc87f7891647eb",
      "NodeType": "FunctionNode",
      "Inputs": [
        {
          "Id": "da740a170b9e4266a409d7cf94eaff3a",
          "Name": "string",
          "Description": "String to split up\n\nstring",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        },
        {
          "Id": "4e75210dc09340c19e9f05b8e60a6ab9",
          "Name": "separator0",
          "Description": "Strings that, if present, determine the end and start of a split.\n\nstring[]",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Outputs": [
        {
          "Id": "3705899635f84ca9b3a8eb37cb566e8a",
          "Name": "strings",
          "Description": "List of strings made from the input string",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Auto",
      "Description": "Divides a single string into a list of strings, with divisions determined by the given separator strings.\n\nString.Split (string: string, separators: string[]): string[]"
    },
    {
      "ConcreteType": "Dynamo.Graph.Nodes.ZeroTouch.DSFunction, DynamoCore",
      "Id": "e512d9dbf76849cabd54d629ee104fa8",
      "NodeType": "FunctionNode",
      "Inputs": [
        {
          "Id": "75867f8f32c046b6abbf91eaaf544a03",
          "Name": "list",
          "Description": "List to remove items from.\n\nvar[]..[]",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        },
        {
          "Id": "fbd448eff8b64d91b85a57905bdc35e6",
          "Name": "amount",
          "Description": "Amount of items to remove. If negative, items are removed from the end of the list.\n\nint",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Outputs": [
        {
          "Id": "651240ac7bd94f09bd9af8e0a2d81eab",
          "Name": "list",
          "Description": "List of remaining items.",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "FunctionSignature": "DSCore.List.DropItems@var[]..[],int",
      "Replication": "Auto",
      "Description": "Removes an amount of items from the start of the list. If the amount is a negative value, items are removed from the end of the list.\n\nList.DropItems (list: var[]..[], amount: int): var[]..[]"
    },
    {
      "ConcreteType": "Dynamo.Graph.Nodes.CodeBlockNodeModel, DynamoCore",
      "Id": "3222b93a482641d6a24121cca19ffe95",
      "NodeType": "CodeBlockNode",
      "Inputs": [],
      "Outputs": [
        {
          "Id": "e7b40d9b9dcc47ebb589491f744c2d31",
          "Name": "",
          "Description": "Value of expression at line 1",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "Allows for DesignScript code to be authored directly",
      "Code": "1;"
    },
    {
      "ConcreteType": "Dynamo.Graph.Nodes.ZeroTouch.DSFunction, DynamoCore",
      "Id": "248643f1169845b7b88a2148bbcd3974",
      "NodeType": "FunctionNode",
      "Inputs": [
        {
          "Id": "8fbc2c1e794248f28f7426c37a5de11b",
          "Name": "list",
          "Description": "List to get the first item from.\n\nvar[]..[]",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": true,
          "KeepListStructure": false
        }
      ],
      "Outputs": [
        {
          "Id": "8d74404b6da941e6ba6981748a460667",
          "Name": "item",
          "Description": "First item in the list.",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "FunctionSignature": "DSCore.List.FirstItem@var[]..[]",
      "Replication": "Auto",
      "Description": "Returns the first item in a list.\n\nList.FirstItem (list: var[]..[]): var[]..[]"
    },
    {
      "ConcreteType": "Dynamo.Graph.Nodes.ZeroTouch.DSFunction, DynamoCore",
      "Id": "71d3671b9faa4b6da5f23fdc4ed86a6d",
      "NodeType": "FunctionNode",
      "Inputs": [
        {
          "Id": "756777b0fefa4701ae797a258880e0bb",
          "Name": "list",
          "Description": "List to filter duplicates out of.\n\nvar[]..[]",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Outputs": [
        {
          "Id": "45125a2c4c354a9c8c44594b5ca3205e",
          "Name": "list",
          "Description": "Filtered list.",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "FunctionSignature": "DSCore.List.UniqueItems@var[]..[]",
      "Replication": "Auto",
      "Description": "Creates a new list containing all unique items in the given list.\n\nList.UniqueItems (list: var[]..[]): var[]..[]"
    },
    {
      "ConcreteType": "CoreNodeModels.Input.StringInput, CoreNodeModels",
      "Id": "4d6c2095d71c4ab2b66216fe71df568f",
      "NodeType": "StringInputNode",
      "Inputs": [],
      "Outputs": [
        {
          "Id": "fc3bfabe1b76406da48a78e96ce2be2c",
          "Name": "",
          "Description": "String",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "Creates a string",
      "InputValue": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace DynaShape.ZeroTouch.Goals\r\n{\r\n    /// <summary>\r\n    /// Class1\r\n    /// </summary>\r\n    public  class Class1\r\n    {\r\n        private Class1(){}\r\n\r\n    }\r\n}\r\n"
    },
    {
      "ConcreteType": "Dynamo.Graph.Nodes.ZeroTouch.DSFunction, DynamoCore",
      "Id": "fe56cd01f58f42d6bb65e29c954708e5",
      "NodeType": "FunctionNode",
      "Inputs": [
        {
          "Id": "6290c17589004ebe91861cd643b4edcd",
          "Name": "string",
          "Description": "String to replace substrings in.\n\nstring",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        },
        {
          "Id": "813ad44d0734411aadf466f2f6fe54a8",
          "Name": "searchFor",
          "Description": "Text to be replaced.\n\nstring",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        },
        {
          "Id": "63b2c64ce2a347f88bb61c97a23a2187",
          "Name": "replaceWith",
          "Description": "Text to replace with.\n\nstring",
          "UsingDefaultValue": false,
          "Level": 1,
          "UseLevels": true,
          "KeepListStructure": false
        }
      ],
      "Outputs": [
        {
          "Id": "55bb05f3ff2e4f0bad3ed0f4c936a69f",
          "Name": "string",
          "Description": "String with replacements made.",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "FunctionSignature": "DSCore.String.Replace@string,string,string",
      "Replication": "Auto",
      "Description": "Replaces all occurrences of text in a string with other text.\n\nString.Replace (string: string, searchFor: string, replaceWith: string): string"
    },
    {
      "ConcreteType": "CoreNodeModels.Input.StringInput, CoreNodeModels",
      "Id": "2b6afb2fe6334c649e1ee747157c2d5e",
      "NodeType": "StringInputNode",
      "Inputs": [],
      "Outputs": [
        {
          "Id": "e60530edc1cd421d93f2c6b9d7425e45",
          "Name": "",
          "Description": "String",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "Creates a string",
      "InputValue": "Class1"
    },
    {
      "ConcreteType": "Dynamo.Graph.Nodes.ZeroTouch.DSFunction, DynamoCore",
      "Id": "8ebc85bea0be47909292588ed4019f55",
      "NodeType": "FunctionNode",
      "Inputs": [
        {
          "Id": "34709e7dd0dc49ee962d79fc1a3d6247",
          "Name": "filePath",
          "Description": "Path to write to\n\nstring",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        },
        {
          "Id": "a28b3a49a3e949dfbdb7506b1d485e9d",
          "Name": "text",
          "Description": "Text content\n\nstring",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Outputs": [
        {
          "Id": "12a930e3d2d24edaa744cbb51ead6435",
          "Name": "void",
          "Description": "No output",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "FunctionSignature": "DSCore.IO.FileSystem.WriteText@string,string",
      "Replication": "Auto",
      "Description": "Write the text content to a file specified by the path\n\nFileSystem.WriteText (filePath: string, text: string): void"
    },
    {
      "ConcreteType": "CoreNodeModels.Input.StringInput, CoreNodeModels",
      "Id": "6e9842d7061449f0a6fe0aa1a2247b9c",
      "NodeType": "StringInputNode",
      "Inputs": [],
      "Outputs": [
        {
          "Id": "2df9ade4f32a462d81d8de63a6816346",
          "Name": "",
          "Description": "String",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "Creates a string",
      "InputValue": "D:\\repos_john\\DynaShape\\DynaShape\\DynaShape\\ZeroTouch\\Goals\\"
    },
    {
      "ConcreteType": "Dynamo.Graph.Nodes.CodeBlockNodeModel, DynamoCore",
      "Id": "013fe81ee1c24bfc9dfa5e4637950ad1",
      "NodeType": "CodeBlockNode",
      "Inputs": [
        {
          "Id": "3b4a415994334d128b57f4f309ec7275",
          "Name": "a",
          "Description": "a",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        },
        {
          "Id": "b605ddc08e404a82a3f33d60f90bae73",
          "Name": "b",
          "Description": "b",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Outputs": [
        {
          "Id": "fafb83f174604934b9945025abf90c0e",
          "Name": "",
          "Description": "Value of expression at line 1",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "Allows for DesignScript code to be authored directly",
      "Code": "a + b + \".cs\";"
    }
  ],
  "Connectors": [
    {
      "Start": "3dc00874a26f4dbca9ed3c91029ed701",
      "End": "9013cfd54b11442fb56f3b46d076fa15",
      "Id": "3f5f179bfb9045419cd1b3b8acb18594",
      "IsHidden": "False"
    },
    {
      "Start": "d3992f15452945f4bea0ce0ed8667a6f",
      "End": "da740a170b9e4266a409d7cf94eaff3a",
      "Id": "dd5203c71638417d9b5ddc27959bedc1",
      "IsHidden": "False"
    },
    {
      "Start": "774087cb9e0c4a38a60a37d38c288575",
      "End": "7b9f298689924d12816bffbc0d55f09b",
      "Id": "bf32604835424dd3884f65e573dd2330",
      "IsHidden": "False"
    },
    {
      "Start": "641e26b436e24fe4be000914b3245a2f",
      "End": "4e75210dc09340c19e9f05b8e60a6ab9",
      "Id": "7d6f5e611d7149648bb8e3c337cf7bae",
      "IsHidden": "False"
    },
    {
      "Start": "3705899635f84ca9b3a8eb37cb566e8a",
      "End": "75867f8f32c046b6abbf91eaaf544a03",
      "Id": "7e9bbd2caa664ed29fe33c6601e02568",
      "IsHidden": "False"
    },
    {
      "Start": "651240ac7bd94f09bd9af8e0a2d81eab",
      "End": "8fbc2c1e794248f28f7426c37a5de11b",
      "Id": "15da820685704be1a3197cc4de9f52ef",
      "IsHidden": "False"
    },
    {
      "Start": "e7b40d9b9dcc47ebb589491f744c2d31",
      "End": "fbd448eff8b64d91b85a57905bdc35e6",
      "Id": "5350269f71d54290b0d54ae4c172218f",
      "IsHidden": "False"
    },
    {
      "Start": "8d74404b6da941e6ba6981748a460667",
      "End": "756777b0fefa4701ae797a258880e0bb",
      "Id": "ed109378ee204137b14c7149f6543ac9",
      "IsHidden": "False"
    },
    {
      "Start": "45125a2c4c354a9c8c44594b5ca3205e",
      "End": "63b2c64ce2a347f88bb61c97a23a2187",
      "Id": "cc5d9f389c8a49a6af83ded0976d7cc4",
      "IsHidden": "False"
    },
    {
      "Start": "45125a2c4c354a9c8c44594b5ca3205e",
      "End": "b605ddc08e404a82a3f33d60f90bae73",
      "Id": "9d734b1fda964175b93b5a9b944c8849",
      "IsHidden": "False"
    },
    {
      "Start": "fc3bfabe1b76406da48a78e96ce2be2c",
      "End": "6290c17589004ebe91861cd643b4edcd",
      "Id": "5cd7b2dcbc2749c199b149750f6d21f4",
      "IsHidden": "False"
    },
    {
      "Start": "55bb05f3ff2e4f0bad3ed0f4c936a69f",
      "End": "a28b3a49a3e949dfbdb7506b1d485e9d",
      "Id": "c0a5eda70d2d4264befc24e96190a3a7",
      "IsHidden": "False"
    },
    {
      "Start": "e60530edc1cd421d93f2c6b9d7425e45",
      "End": "813ad44d0734411aadf466f2f6fe54a8",
      "Id": "5c32a04260ec4d9c815a7cc1dc2590e0",
      "IsHidden": "False"
    },
    {
      "Start": "2df9ade4f32a462d81d8de63a6816346",
      "End": "3b4a415994334d128b57f4f309ec7275",
      "Id": "770fd60dc4354768b1e95b69d3b6c709",
      "IsHidden": "False"
    },
    {
      "Start": "fafb83f174604934b9945025abf90c0e",
      "End": "34709e7dd0dc49ee962d79fc1a3d6247",
      "Id": "998c5eb62c77452bbaab5ff703a36314",
      "IsHidden": "False"
    }
  ],
  "Dependencies": [],
  "NodeLibraryDependencies": [],
  "EnableLegacyPolyCurveBehavior": null,
  "Thumbnail": "",
  "GraphDocumentationURL": null,
  "ExtensionWorkspaceData": [
    {
      "ExtensionGuid": "28992e1d-abb9-417f-8b1b-05e053bee670",
      "Name": "Properties",
      "Version": "3.0",
      "Data": {}
    },
    {
      "ExtensionGuid": "DFBD9CC0-DB40-457A-939E-8C8555555A9D",
      "Name": "Generative Design",
      "Version": "7.1",
      "Data": {}
    }
  ],
  "Author": "",
  "Linting": {
    "activeLinter": "None",
    "activeLinterId": "7b75fb44-43fd-4631-a878-29f4d5d8399a",
    "warningCount": 0,
    "errorCount": 0
  },
  "Bindings": [],
  "View": {
    "Dynamo": {
      "ScaleFactor": 1.0,
      "HasRunWithoutCrash": true,
      "IsVisibleInDynamoLibrary": true,
      "Version": "3.0.4.7905",
      "RunType": "Manual",
      "RunPeriod": "1000"
    },
    "Camera": {
      "Name": "_Background Preview",
      "EyeX": -17.0,
      "EyeY": 24.0,
      "EyeZ": 50.0,
      "LookX": 12.0,
      "LookY": -13.0,
      "LookZ": -58.0,
      "UpX": 0.0,
      "UpY": 1.0,
      "UpZ": 0.0
    },
    "ConnectorPins": [],
    "NodeViews": [
      {
        "Id": "6fabbfab180d4e87ae472cf4fd979d19",
        "Name": "String",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "ShowGeometry": true,
        "X": 336.7999999999998,
        "Y": 178.4000000000001
      },
      {
        "Id": "f9d88a0265954657b0318b4f0dcc2d6a",
        "Name": "String.Split",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "ShowGeometry": true,
        "X": 1411.4175563666495,
        "Y": 329.4430797527039
      },
      {
        "Id": "66d7f364dc6349bc9d8ebaf5cb104d8c",
        "Name": "String",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "ShowGeometry": true,
        "X": 881.976477173273,
        "Y": 602.6888543515558
      },
      {
        "Id": "2b846337d8bd409dbd6f177104a57270",
        "Name": "String",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "ShowGeometry": true,
        "X": 877.3478372493644,
        "Y": 739.2337321068682
      },
      {
        "Id": "f802dc9b651541798ecc87f7891647eb",
        "Name": "String.Split",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "ShowGeometry": true,
        "X": 2004.9146696831258,
        "Y": 341.1277150930299
      },
      {
        "Id": "e512d9dbf76849cabd54d629ee104fa8",
        "Name": "List.DropItems",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "ShowGeometry": true,
        "X": 2541.8632660830076,
        "Y": 482.45908340717574
      },
      {
        "Id": "3222b93a482641d6a24121cca19ffe95",
        "Name": "Code Block",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "ShowGeometry": true,
        "X": 2264.0,
        "Y": 547.0
      },
      {
        "Id": "248643f1169845b7b88a2148bbcd3974",
        "Name": "List.FirstItem",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "ShowGeometry": true,
        "X": 2869.9128466331904,
        "Y": 486.4114879921177
      },
      {
        "Id": "71d3671b9faa4b6da5f23fdc4ed86a6d",
        "Name": "List.UniqueItems",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "ShowGeometry": true,
        "X": 3274.9346689887316,
        "Y": 498.5607574454398
      },
      {
        "Id": "4d6c2095d71c4ab2b66216fe71df568f",
        "Name": "String",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "ShowGeometry": true,
        "X": 2983.114532841305,
        "Y": 1064.9480628799688
      },
      {
        "Id": "fe56cd01f58f42d6bb65e29c954708e5",
        "Name": "String.Replace",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "ShowGeometry": true,
        "X": 4023.6033504691623,
        "Y": 951.1168076181177
      },
      {
        "Id": "2b6afb2fe6334c649e1ee747157c2d5e",
        "Name": "String",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "ShowGeometry": true,
        "X": 3459.7829142503065,
        "Y": 1145.874970917691
      },
      {
        "Id": "8ebc85bea0be47909292588ed4019f55",
        "Name": "FileSystem.WriteText",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "ShowGeometry": true,
        "X": 5330.779447772608,
        "Y": 1065.406311323136
      },
      {
        "Id": "6e9842d7061449f0a6fe0aa1a2247b9c",
        "Name": "String",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "ShowGeometry": true,
        "X": 4609.569467780193,
        "Y": 1341.07422151696
      },
      {
        "Id": "013fe81ee1c24bfc9dfa5e4637950ad1",
        "Name": "Code Block",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "ShowGeometry": true,
        "X": 4962.185651524832,
        "Y": 1472.7652273014837
      }
    ],
    "Annotations": [],
    "X": -2131.7722625639517,
    "Y": -369.8088571319786,
    "Zoom": 0.687429564313341
  }
}